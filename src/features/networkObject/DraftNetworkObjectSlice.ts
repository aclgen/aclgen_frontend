import { NetworkObjectElement } from "../../types/types";
import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";

import type { AppState, AppThunk } from "../../app/store";
import { fetchNetworkObjects } from "./networkObjectAPI";
import {
  cancelCreationPopUp,
  initiateNewService,
} from "../service/DraftServiceSlice";
import { initiateNewRule } from "../rules/ruleSlice";

export interface DraftNetworkObjectState {
  networkObjects: NetworkObjectElement[];
  status: "empty" | "idle" | "loading" | "failed";
  newObjectStatus: "idle" | "creating" | "editing";
  newObject: NetworkObjectElement | undefined;
}

const initialState: DraftNetworkObjectState = {
  networkObjects: [],
  status: "empty",
  newObjectStatus: "idle",
  newObject: undefined,
};

export const DraftNetworkObjectSlice = createSlice({
  name: "draftNetworkObject",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    updateNetworkObjects: (
      state,
      action: PayloadAction<NetworkObjectElement[]>
    ) => {
      state.networkObjects = action.payload;
      state.status = "idle";
    },
    createNewNetworkObject: (
      state,
      action: PayloadAction<NetworkObjectElement>
    ) => {
      state.newObject = undefined;
      state.networkObjects = [...state.networkObjects, action.payload];
      state.newObjectStatus = "idle";
    },
    modifyNetworkObject: (
      state,
      action: PayloadAction<NetworkObjectElement>
    ) => {
      state.newObject = undefined;
      state.newObjectStatus = "idle";
      const index = state.networkObjects.findIndex(
        (element) => element.id === action.payload.id
      );
      state.networkObjects = [
        ...state.networkObjects.slice(0, index),
        action.payload,
        ...state.networkObjects.slice(index + 1),
      ];
    },
    initiateModifyNetworkObject: (
      state,
      action: PayloadAction<NetworkObjectElement>
    ) => {
      if (
        state.newObjectStatus === "editing" &&
        state.newObject.id === action.payload.id
      ) {
        state.newObject = undefined;
        state.newObjectStatus = "idle";
      } else {
        state.newObject = action.payload;
        state.newObjectStatus = "editing";
      }
    },
    initiateNewObject: (state) => {
      state.newObject = undefined;
      state.newObjectStatus = "creating";
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder.addCase(initiateNewService, (state, payload) => {
      state.newObject = undefined;
      state.newObjectStatus = "idle";
    });
    builder.addCase(initiateNewRule, (state, payload) => {
      state.newObject = undefined;
      state.newObjectStatus = "idle";
    });
    builder.addCase(cancelCreationPopUp, (state) => {
      state.newObject = undefined;
      state.newObjectStatus = "idle";
    });
  },
});

export const {
  updateNetworkObjects,
  createNewNetworkObject,
  initiateNewObject,
  modifyNetworkObject,
  initiateModifyNetworkObject,
} = DraftNetworkObjectSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectNetworkObjects = (state: AppState) => state.networkObject;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.

export default DraftNetworkObjectSlice.reducer;
